<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.3" />
<title>rockyraccoon.model.core API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>rockyraccoon.model.core</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>Source code</summary>
<pre><code class="python">import numpy as np

import pennylane as qml
from pennylane.ops.qubit import QubitStateVector
import itertools as it

import tensorflow as tf

tf.enable_eager_execution()


class RockyModel(tf.keras.Model):
    &#34;&#34;&#34;
    QML model template.
    &#34;&#34;&#34;

    def __init__(self, nclasses: int, device=&#34;default.qubit&#34;):
        &#34;&#34;&#34;
        Initialize the keras model interface.

        Args:
            nclasses: The number of classes in the data, used the determine the required output qubits.
            device: name of Pennylane Device backend.
        &#34;&#34;&#34;
        super(RockyModel, self).__init__()
        self.req_qub_out = int(np.ceil(np.log2(nclasses)))
        self.req_qub_in = None
        self.device = device
        self.data_dev = None
        self.model_dev = None
        self.nclasses = nclasses
        self.init = False
        self.circuit = None
        self.trainable_vars = []

    def __str__(self):
        return &#34;RockyModel Template&#34;

    def initialize(self, nfeatures: int):
        &#34;&#34;&#34;
        Model initialization.

        Args:
            nfeatures: The number of features in X

        &#34;&#34;&#34;
        self.init = True
        raise NotImplementedError

    def call(self, inputs, observable):
        &#34;&#34;&#34;
        Given some obsersable, we calculate the output of the model.

        Args:
            inputs: N x d matrix of N samples and d features.
            observable: Hermitian matrix containing an observable

        Returns: N expectation values of the observable

        &#34;&#34;&#34;

        raise NotImplementedError


class RaccoonWrapper:
    &#34;&#34;&#34;
    QML model training
    &#34;&#34;&#34;

    # TODO convert everything to complex128?
    measurements = {
        &#34;sx&#34;: tf.constant(np.array([[0, 1], [1, 0]]), dtype=tf.float64),
        &#34;sy&#34;: tf.constant(
            np.array([[0, complex(0, -1)], [complex(0, 1), 0]]), dtype=tf.float64
        ),
        &#34;sz&#34;: tf.constant(np.array([[1, 0], [0, -1]]), dtype=tf.float64),
        &#34;id&#34;: tf.constant(np.array([[1, 0], [0, 1]]), dtype=tf.float64),
    }

    def __init__(self, model: RockyModel):
        &#34;&#34;&#34;
        Wrapper allows one to minimize the quantum log-likelihood for a given RockyModel

        Args:
            model: The QML model we want to use for learning
        &#34;&#34;&#34;

        self.Q = None
        self.q_y_x = None
        self.q_x = None
        self.req_measurements = None
        self.model = model
        self.bias = True

        def circuit(x, obs=None):
            QubitStateVector(x, wires=list(range(self.model.req_qub_out)))
            return qml.expval.Hermitian(obs, wires=list(range(self.model.req_qub_out)))

        self.data_circuit = qml.QNode(circuit, device=self.model.data_dev, cache=True)

    def _get_discr_statistics(self, X: np.ndarray, y: np.ndarray) -&gt; None:
        &#34;&#34;&#34;
        Calculate the empirical distribution q(y|x) for data X and labels y.

        Args:
            X: N x d matrix of N samples and d features.
            y: Length N vector with labels

        &#34;&#34;&#34;
        y = y.flatten()
        assert X.shape[0] == y.shape[0], &#34;Data has {} samples with {} labels&#34;.format(
            X.shape[0], X.shape[1]
        )

        classes = np.unique(y)
        nsamples, nfeatures = X.shape

        def _q_y_x(c: int, sample: np.ndarray) -&gt; np.ndarray:
            # find copies of our sample
            _idx = np.where((X == tuple(sample)).all(axis=1))[0]
            # return probablity q(y=1|x)
            return np.sum(y[_idx] == c) / len(_idx)

        def _q_x(sample: np.ndarray) -&gt; np.ndarray:
            # find copies of our sample
            _idx = np.where((X == tuple(sample)).all(axis=1))[0]
            # calcualte emperical probability of sample
            return len(_idx) / X.shape[0]

        # Initialize arrays
        self.q_y_x = np.zeros((nsamples, len(classes)))
        self.q_x = np.zeros((nsamples, 1))
        # Get statistics per class
        for i in range(nsamples):
            for j, cl in enumerate(classes):
                self.q_y_x[i, j] = _q_y_x(cl, X[i, :])
            self.q_x[i] = _q_x(X[i, :])

    def _determine_req_measurements(self, complex=False) -&gt; None:
        &#34;&#34;&#34;
        Determine which measurements are required for constructing the density matrix.

        Args:
            complex: Boolean that determines whether we care about SigmaY observables.

        Returns: list of requirement measurements.

        &#34;&#34;&#34;

        measurements = []
        if complex:
            for m in it.product(
                [&#34;sx&#34;, &#34;sy&#34;, &#34;sz&#34;, &#34;id&#34;], repeat=self.model.req_qub_out
            ):
                measurements.append(m)
        else:
            for m in it.product([&#34;sx&#34;, &#34;sz&#34;, &#34;id&#34;], repeat=self.model.req_qub_out):
                measurements.append(m)
        # remove the idenity measurement
        measurements.remove(tuple(&#34;id&#34; for _ in range(self.model.req_qub_out)))
        # create constant tensor containing the required measurements.
        self.req_measurements = []
        for m in measurements:
            obs = 1
            for ob in m:
                obs = np.kron(obs, RaccoonWrapper.measurements[ob])
            self.req_measurements.append(obs)
        self.req_measurements = tf.constant(self.req_measurements, dtype=tf.float64)

    def construct_density_matrix(self, phi: np.ndarray) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Construct the pure density matrix belonging to a certain wavefunction using a quantum circuit.

        Args:
            phi: Amplitudes of wavefunction (should be normed).

        Returns: A density matrix as ndarray.

        &#34;&#34;&#34;
        # Fill the full wavefunction with the conditional probabilities q(x|y)
        full_phi = np.zeros((2 ** self.model.req_qub_out))
        full_phi[: len(phi)] = phi

        assert np.isclose(
            sum(np.abs(full_phi) ** 2), 1
        ), &#34;Wavefunction must be normed to 1&#34;
        # obtain the required expectation values to construct the density matrix from the data circuit.
        expval = (
            self.req_measurements
            * tf.map_fn(
                lambda x: self.data_circuit(full_phi, obs=x.numpy()),
                self.req_measurements,
                dtype=tf.float64,
            )[:, tf.newaxis, tf.newaxis]
        )
        # combine the tomography measurements
        eta = tf.reduce_sum(expval, axis=0)
        eta += tf.eye(
            2 ** self.model.req_qub_out, 2 ** self.model.req_qub_out, dtype=tf.float64
        )
        # normalization,
        eta /= tf.trace(eta)
        return eta

    def loss(self, inputs: np.ndarray, eta: tf.Tensor) -&gt; tf.float64:
        &#34;&#34;&#34;
        Determine the quantum log-likelihood of a batch of inputs, eta is the
        corresponding data density matrix

        Args:
            inputs: Mxd matrix of a batch of M samples with d features
            eta: Data density matrices for each sample so a rank 3 tensor.

        Returns: Scalar with quantum log-likelihood

        &#34;&#34;&#34;
        assert self.model.init, &#34;Initialize the model before calculating the loss&#34;

        # obtain the required expectation values to construct the density matrix from the data circuit.
        expval = tf.map_fn(
            lambda x: self.model(inputs, x), self.req_measurements, dtype=tf.float64
        )
        expval = tf.transpose(expval)
        rho = tf.einsum(&#34;no,oij-&gt;nij&#34;, expval, self.req_measurements)
        rho += tf.eye(
            2 ** self.model.req_qub_out, 2 ** self.model.req_qub_out, dtype=tf.float64
        )
        # normalization
        rho /= tf.trace(rho)[:, tf.newaxis, tf.newaxis]
        log_rho = self._matrix_log(rho)
        # calculate quantum log-likelihood
        lh = -tf.trace(eta @ log_rho)
        # aggregate loss over all samples
        return tf.reduce_mean(lh)

    def train(self, X: np.ndarray, y: np.ndarray, epsilon=0.1, maxiter=100, tol=0.1):
        &#34;&#34;&#34;
        Train the QML model with gradient descent.

        Args:
            X: N x d matrix of N samples and d features.
            y: Length N vector with labels.
            epsilon: Learning rate of the optimizer.
            maxiter: Maximum number of iterations before convergence.
            tol: Likelihood tolerance threshhold.

        &#34;&#34;&#34;
        # add bias to inputs
        if self.model.bias:
            X = self.add_bias(X)

        assert self.model.nclasses == len(
            np.unique(y)
        ), &#34;Model expects at {} classes, when y contains {} classes&#34;.format(
            self.model.nclasses, len(np.unique(y))
        )
        # determine the required measurements and get empirical statistics
        self._determine_req_measurements(False)
        self._get_discr_statistics(X, y)
        data_states = tf.map_fn(
            self.construct_density_matrix, np.sqrt(self.q_y_x), dtype=tf.float64
        )
        # multiply with qx (prior)
        data_states *= tf.reshape(self.q_x, (-1, 1, 1))
        # intialize the model
        self.model.initialize(X.shape[1])

        optimizer = tf.compat.v1.train.GradientDescentOptimizer(learning_rate=epsilon)
        self.lh = []
        # print training info
        print(&#34;-------TRAINING-------&#34;)
        print(self.model)
        print(&#34;{} samples, {} features&#34;.format(*X.shape))
        print(
            &#34;{} input qubits, {} output qubits&#34;.format(
                self.model.req_qub_in, self.model.req_qub_out
            )
        )
        # training loop
        for i in range(maxiter):
            # calculate and apply gradients
            with tf.GradientTape() as tape:
                loss_value = self.loss(X, data_states)
                grads = tape.gradient(loss_value, self.model.trainable_vars)
            optimizer.apply_gradients(
                zip(grads, self.model.trainable_vars),
                global_step=tf.compat.v1.train.get_or_create_global_step(),
            )
            self.lh.append(float(loss_value))
            if i % 20 == 0:
                print(&#34;Loss at step {:03d}: {:.6f}&#34;.format(i, loss_value))
                if abs(loss_value - self.loss(X, data_states)) &lt; tol:
                    print(&#34;L&lt;{} after {:03d} iterations&#34;.format(tol, i))

                    break
        print(&#34;Final loss: {:.6f}&#34;.format(self.loss(X, data_states)))

    def predict(self, inputs: np.ndarray) -&gt; np.ndarray:
        &#34;&#34;&#34;

        Args:
            inputs: Mxd matrix of a batch of M samples with d features

        Returns: array of size M x nclasses with probabilities

        &#34;&#34;&#34;

        assert self.model.init, &#34;Initialize the model before predicting data&#34;
        # obtain the required expectation values to construct the density matrix from the data circuit.
        expval = tf.map_fn(
            lambda x: self.model(inputs, x), self.req_measurements, dtype=tf.float64
        )
        expval = tf.transpose(expval)
        # combine the tomography measurements
        rho = tf.einsum(&#34;no,oij-&gt;nij&#34;, expval, self.req_measurements)
        rho += tf.eye(
            2 ** self.model.req_qub_out, 2 ** self.model.req_qub_out, dtype=tf.float64
        )
        # normalization
        rho /= tf.trace(rho)[:, tf.newaxis, tf.newaxis]
        # stack probabilties for their respective classes
        return tf.stack(
            [tf.to_float(rho[:, i, i]) for i in range(rho.shape[1])], axis=1
        ).numpy()

    @staticmethod
    def _matrix_log(matrix: tf.Tensor) -&gt; tf.Tensor:
        &#34;&#34;&#34;
        Calculate matrix log2 through diagonalization of Hermitian matrix  M = U^-1 D U

        Args:
            matrix: N x N matrix

        Returns: N x N matrix

        &#34;&#34;&#34;
        rx, Ux = tf.linalg.eigh(matrix)
        Ux_inv = tf.linalg.adjoint(Ux)
        rx = tf.cast(
            tf.math.log(tf.clip_by_value(tf.math.real(rx), 1e-13, 1e13)), rx.dtype
        )
        tx = tf.linalg.LinearOperatorDiag(rx).to_dense()
        return tf.matmul(Ux, tf.matmul(tx, Ux_inv))

    @staticmethod
    def add_bias(X: np.ndarray) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Add a bias to the input data by adding a column of ones.

        Args:
            X: Numpy array of size N x d

        Returns: Numpy array of size N x d+1

        &#34;&#34;&#34;
        n_samples = X.shape[0]
        return np.hstack([X, np.ones((n_samples, 1))])</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="rockyraccoon.model.core.RaccoonWrapper"><code class="flex name class">
<span>class <span class="ident">RaccoonWrapper</span></span>
<span>(</span><span>model)</span>
</code></dt>
<dd>
<section class="desc"><p>QML model training</p>
<p>Wrapper allows one to minimize the quantum log-likelihood for a given RockyModel</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model</code></strong></dt>
<dd>The QML model we want to use for learning</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class RaccoonWrapper:
    &#34;&#34;&#34;
    QML model training
    &#34;&#34;&#34;

    # TODO convert everything to complex128?
    measurements = {
        &#34;sx&#34;: tf.constant(np.array([[0, 1], [1, 0]]), dtype=tf.float64),
        &#34;sy&#34;: tf.constant(
            np.array([[0, complex(0, -1)], [complex(0, 1), 0]]), dtype=tf.float64
        ),
        &#34;sz&#34;: tf.constant(np.array([[1, 0], [0, -1]]), dtype=tf.float64),
        &#34;id&#34;: tf.constant(np.array([[1, 0], [0, 1]]), dtype=tf.float64),
    }

    def __init__(self, model: RockyModel):
        &#34;&#34;&#34;
        Wrapper allows one to minimize the quantum log-likelihood for a given RockyModel

        Args:
            model: The QML model we want to use for learning
        &#34;&#34;&#34;

        self.Q = None
        self.q_y_x = None
        self.q_x = None
        self.req_measurements = None
        self.model = model
        self.bias = True

        def circuit(x, obs=None):
            QubitStateVector(x, wires=list(range(self.model.req_qub_out)))
            return qml.expval.Hermitian(obs, wires=list(range(self.model.req_qub_out)))

        self.data_circuit = qml.QNode(circuit, device=self.model.data_dev, cache=True)

    def _get_discr_statistics(self, X: np.ndarray, y: np.ndarray) -&gt; None:
        &#34;&#34;&#34;
        Calculate the empirical distribution q(y|x) for data X and labels y.

        Args:
            X: N x d matrix of N samples and d features.
            y: Length N vector with labels

        &#34;&#34;&#34;
        y = y.flatten()
        assert X.shape[0] == y.shape[0], &#34;Data has {} samples with {} labels&#34;.format(
            X.shape[0], X.shape[1]
        )

        classes = np.unique(y)
        nsamples, nfeatures = X.shape

        def _q_y_x(c: int, sample: np.ndarray) -&gt; np.ndarray:
            # find copies of our sample
            _idx = np.where((X == tuple(sample)).all(axis=1))[0]
            # return probablity q(y=1|x)
            return np.sum(y[_idx] == c) / len(_idx)

        def _q_x(sample: np.ndarray) -&gt; np.ndarray:
            # find copies of our sample
            _idx = np.where((X == tuple(sample)).all(axis=1))[0]
            # calcualte emperical probability of sample
            return len(_idx) / X.shape[0]

        # Initialize arrays
        self.q_y_x = np.zeros((nsamples, len(classes)))
        self.q_x = np.zeros((nsamples, 1))
        # Get statistics per class
        for i in range(nsamples):
            for j, cl in enumerate(classes):
                self.q_y_x[i, j] = _q_y_x(cl, X[i, :])
            self.q_x[i] = _q_x(X[i, :])

    def _determine_req_measurements(self, complex=False) -&gt; None:
        &#34;&#34;&#34;
        Determine which measurements are required for constructing the density matrix.

        Args:
            complex: Boolean that determines whether we care about SigmaY observables.

        Returns: list of requirement measurements.

        &#34;&#34;&#34;

        measurements = []
        if complex:
            for m in it.product(
                [&#34;sx&#34;, &#34;sy&#34;, &#34;sz&#34;, &#34;id&#34;], repeat=self.model.req_qub_out
            ):
                measurements.append(m)
        else:
            for m in it.product([&#34;sx&#34;, &#34;sz&#34;, &#34;id&#34;], repeat=self.model.req_qub_out):
                measurements.append(m)
        # remove the idenity measurement
        measurements.remove(tuple(&#34;id&#34; for _ in range(self.model.req_qub_out)))
        # create constant tensor containing the required measurements.
        self.req_measurements = []
        for m in measurements:
            obs = 1
            for ob in m:
                obs = np.kron(obs, RaccoonWrapper.measurements[ob])
            self.req_measurements.append(obs)
        self.req_measurements = tf.constant(self.req_measurements, dtype=tf.float64)

    def construct_density_matrix(self, phi: np.ndarray) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Construct the pure density matrix belonging to a certain wavefunction using a quantum circuit.

        Args:
            phi: Amplitudes of wavefunction (should be normed).

        Returns: A density matrix as ndarray.

        &#34;&#34;&#34;
        # Fill the full wavefunction with the conditional probabilities q(x|y)
        full_phi = np.zeros((2 ** self.model.req_qub_out))
        full_phi[: len(phi)] = phi

        assert np.isclose(
            sum(np.abs(full_phi) ** 2), 1
        ), &#34;Wavefunction must be normed to 1&#34;
        # obtain the required expectation values to construct the density matrix from the data circuit.
        expval = (
            self.req_measurements
            * tf.map_fn(
                lambda x: self.data_circuit(full_phi, obs=x.numpy()),
                self.req_measurements,
                dtype=tf.float64,
            )[:, tf.newaxis, tf.newaxis]
        )
        # combine the tomography measurements
        eta = tf.reduce_sum(expval, axis=0)
        eta += tf.eye(
            2 ** self.model.req_qub_out, 2 ** self.model.req_qub_out, dtype=tf.float64
        )
        # normalization,
        eta /= tf.trace(eta)
        return eta

    def loss(self, inputs: np.ndarray, eta: tf.Tensor) -&gt; tf.float64:
        &#34;&#34;&#34;
        Determine the quantum log-likelihood of a batch of inputs, eta is the
        corresponding data density matrix

        Args:
            inputs: Mxd matrix of a batch of M samples with d features
            eta: Data density matrices for each sample so a rank 3 tensor.

        Returns: Scalar with quantum log-likelihood

        &#34;&#34;&#34;
        assert self.model.init, &#34;Initialize the model before calculating the loss&#34;

        # obtain the required expectation values to construct the density matrix from the data circuit.
        expval = tf.map_fn(
            lambda x: self.model(inputs, x), self.req_measurements, dtype=tf.float64
        )
        expval = tf.transpose(expval)
        rho = tf.einsum(&#34;no,oij-&gt;nij&#34;, expval, self.req_measurements)
        rho += tf.eye(
            2 ** self.model.req_qub_out, 2 ** self.model.req_qub_out, dtype=tf.float64
        )
        # normalization
        rho /= tf.trace(rho)[:, tf.newaxis, tf.newaxis]
        log_rho = self._matrix_log(rho)
        # calculate quantum log-likelihood
        lh = -tf.trace(eta @ log_rho)
        # aggregate loss over all samples
        return tf.reduce_mean(lh)

    def train(self, X: np.ndarray, y: np.ndarray, epsilon=0.1, maxiter=100, tol=0.1):
        &#34;&#34;&#34;
        Train the QML model with gradient descent.

        Args:
            X: N x d matrix of N samples and d features.
            y: Length N vector with labels.
            epsilon: Learning rate of the optimizer.
            maxiter: Maximum number of iterations before convergence.
            tol: Likelihood tolerance threshhold.

        &#34;&#34;&#34;
        # add bias to inputs
        if self.model.bias:
            X = self.add_bias(X)

        assert self.model.nclasses == len(
            np.unique(y)
        ), &#34;Model expects at {} classes, when y contains {} classes&#34;.format(
            self.model.nclasses, len(np.unique(y))
        )
        # determine the required measurements and get empirical statistics
        self._determine_req_measurements(False)
        self._get_discr_statistics(X, y)
        data_states = tf.map_fn(
            self.construct_density_matrix, np.sqrt(self.q_y_x), dtype=tf.float64
        )
        # multiply with qx (prior)
        data_states *= tf.reshape(self.q_x, (-1, 1, 1))
        # intialize the model
        self.model.initialize(X.shape[1])

        optimizer = tf.compat.v1.train.GradientDescentOptimizer(learning_rate=epsilon)
        self.lh = []
        # print training info
        print(&#34;-------TRAINING-------&#34;)
        print(self.model)
        print(&#34;{} samples, {} features&#34;.format(*X.shape))
        print(
            &#34;{} input qubits, {} output qubits&#34;.format(
                self.model.req_qub_in, self.model.req_qub_out
            )
        )
        # training loop
        for i in range(maxiter):
            # calculate and apply gradients
            with tf.GradientTape() as tape:
                loss_value = self.loss(X, data_states)
                grads = tape.gradient(loss_value, self.model.trainable_vars)
            optimizer.apply_gradients(
                zip(grads, self.model.trainable_vars),
                global_step=tf.compat.v1.train.get_or_create_global_step(),
            )
            self.lh.append(float(loss_value))
            if i % 20 == 0:
                print(&#34;Loss at step {:03d}: {:.6f}&#34;.format(i, loss_value))
                if abs(loss_value - self.loss(X, data_states)) &lt; tol:
                    print(&#34;L&lt;{} after {:03d} iterations&#34;.format(tol, i))

                    break
        print(&#34;Final loss: {:.6f}&#34;.format(self.loss(X, data_states)))

    def predict(self, inputs: np.ndarray) -&gt; np.ndarray:
        &#34;&#34;&#34;

        Args:
            inputs: Mxd matrix of a batch of M samples with d features

        Returns: array of size M x nclasses with probabilities

        &#34;&#34;&#34;

        assert self.model.init, &#34;Initialize the model before predicting data&#34;
        # obtain the required expectation values to construct the density matrix from the data circuit.
        expval = tf.map_fn(
            lambda x: self.model(inputs, x), self.req_measurements, dtype=tf.float64
        )
        expval = tf.transpose(expval)
        # combine the tomography measurements
        rho = tf.einsum(&#34;no,oij-&gt;nij&#34;, expval, self.req_measurements)
        rho += tf.eye(
            2 ** self.model.req_qub_out, 2 ** self.model.req_qub_out, dtype=tf.float64
        )
        # normalization
        rho /= tf.trace(rho)[:, tf.newaxis, tf.newaxis]
        # stack probabilties for their respective classes
        return tf.stack(
            [tf.to_float(rho[:, i, i]) for i in range(rho.shape[1])], axis=1
        ).numpy()

    @staticmethod
    def _matrix_log(matrix: tf.Tensor) -&gt; tf.Tensor:
        &#34;&#34;&#34;
        Calculate matrix log2 through diagonalization of Hermitian matrix  M = U^-1 D U

        Args:
            matrix: N x N matrix

        Returns: N x N matrix

        &#34;&#34;&#34;
        rx, Ux = tf.linalg.eigh(matrix)
        Ux_inv = tf.linalg.adjoint(Ux)
        rx = tf.cast(
            tf.math.log(tf.clip_by_value(tf.math.real(rx), 1e-13, 1e13)), rx.dtype
        )
        tx = tf.linalg.LinearOperatorDiag(rx).to_dense()
        return tf.matmul(Ux, tf.matmul(tx, Ux_inv))

    @staticmethod
    def add_bias(X: np.ndarray) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Add a bias to the input data by adding a column of ones.

        Args:
            X: Numpy array of size N x d

        Returns: Numpy array of size N x d+1

        &#34;&#34;&#34;
        n_samples = X.shape[0]
        return np.hstack([X, np.ones((n_samples, 1))])</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="rockyraccoon.model.core.RaccoonWrapper.measurements"><code class="name">var <span class="ident">measurements</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="rockyraccoon.model.core.RaccoonWrapper.add_bias"><code class="name flex">
<span>def <span class="ident">add_bias</span></span>(<span>X)</span>
</code></dt>
<dd>
<section class="desc"><p>Add a bias to the input data by adding a column of ones.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>X</code></strong></dt>
<dd>Numpy array of size N x d</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code>Numpy</code> <code>array</code> of <code>size</code> <code>N</code> <code>x</code> <code>d</code>+<code>1</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@staticmethod
def add_bias(X: np.ndarray) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Add a bias to the input data by adding a column of ones.

    Args:
        X: Numpy array of size N x d

    Returns: Numpy array of size N x d+1

    &#34;&#34;&#34;
    n_samples = X.shape[0]
    return np.hstack([X, np.ones((n_samples, 1))])</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="rockyraccoon.model.core.RaccoonWrapper.construct_density_matrix"><code class="name flex">
<span>def <span class="ident">construct_density_matrix</span></span>(<span>self, phi)</span>
</code></dt>
<dd>
<section class="desc"><p>Construct the pure density matrix belonging to a certain wavefunction using a quantum circuit.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>phi</code></strong></dt>
<dd>Amplitudes of wavefunction (should be normed).</dd>
</dl>
<p>Returns: A density matrix as ndarray.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def construct_density_matrix(self, phi: np.ndarray) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Construct the pure density matrix belonging to a certain wavefunction using a quantum circuit.

    Args:
        phi: Amplitudes of wavefunction (should be normed).

    Returns: A density matrix as ndarray.

    &#34;&#34;&#34;
    # Fill the full wavefunction with the conditional probabilities q(x|y)
    full_phi = np.zeros((2 ** self.model.req_qub_out))
    full_phi[: len(phi)] = phi

    assert np.isclose(
        sum(np.abs(full_phi) ** 2), 1
    ), &#34;Wavefunction must be normed to 1&#34;
    # obtain the required expectation values to construct the density matrix from the data circuit.
    expval = (
        self.req_measurements
        * tf.map_fn(
            lambda x: self.data_circuit(full_phi, obs=x.numpy()),
            self.req_measurements,
            dtype=tf.float64,
        )[:, tf.newaxis, tf.newaxis]
    )
    # combine the tomography measurements
    eta = tf.reduce_sum(expval, axis=0)
    eta += tf.eye(
        2 ** self.model.req_qub_out, 2 ** self.model.req_qub_out, dtype=tf.float64
    )
    # normalization,
    eta /= tf.trace(eta)
    return eta</code></pre>
</details>
</dd>
<dt id="rockyraccoon.model.core.RaccoonWrapper.loss"><code class="name flex">
<span>def <span class="ident">loss</span></span>(<span>self, inputs, eta)</span>
</code></dt>
<dd>
<section class="desc"><p>Determine the quantum log-likelihood of a batch of inputs, eta is the
corresponding data density matrix</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>inputs</code></strong></dt>
<dd>Mxd matrix of a batch of M samples with d features</dd>
<dt><strong><code>eta</code></strong></dt>
<dd>Data density matrices for each sample so a rank 3 tensor.</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code>Scalar</code> <code>with</code> <code>quantum</code> <code>log</code>-<code>likelihood</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def loss(self, inputs: np.ndarray, eta: tf.Tensor) -&gt; tf.float64:
    &#34;&#34;&#34;
    Determine the quantum log-likelihood of a batch of inputs, eta is the
    corresponding data density matrix

    Args:
        inputs: Mxd matrix of a batch of M samples with d features
        eta: Data density matrices for each sample so a rank 3 tensor.

    Returns: Scalar with quantum log-likelihood

    &#34;&#34;&#34;
    assert self.model.init, &#34;Initialize the model before calculating the loss&#34;

    # obtain the required expectation values to construct the density matrix from the data circuit.
    expval = tf.map_fn(
        lambda x: self.model(inputs, x), self.req_measurements, dtype=tf.float64
    )
    expval = tf.transpose(expval)
    rho = tf.einsum(&#34;no,oij-&gt;nij&#34;, expval, self.req_measurements)
    rho += tf.eye(
        2 ** self.model.req_qub_out, 2 ** self.model.req_qub_out, dtype=tf.float64
    )
    # normalization
    rho /= tf.trace(rho)[:, tf.newaxis, tf.newaxis]
    log_rho = self._matrix_log(rho)
    # calculate quantum log-likelihood
    lh = -tf.trace(eta @ log_rho)
    # aggregate loss over all samples
    return tf.reduce_mean(lh)</code></pre>
</details>
</dd>
<dt id="rockyraccoon.model.core.RaccoonWrapper.predict"><code class="name flex">
<span>def <span class="ident">predict</span></span>(<span>self, inputs)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>inputs</code></strong></dt>
<dd>Mxd matrix of a batch of M samples with d features</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code>array</code> of <code>size</code> <code>M</code> <code>x</code> <code>nclasses</code> <code>with</code> <code>probabilities</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def predict(self, inputs: np.ndarray) -&gt; np.ndarray:
    &#34;&#34;&#34;

    Args:
        inputs: Mxd matrix of a batch of M samples with d features

    Returns: array of size M x nclasses with probabilities

    &#34;&#34;&#34;

    assert self.model.init, &#34;Initialize the model before predicting data&#34;
    # obtain the required expectation values to construct the density matrix from the data circuit.
    expval = tf.map_fn(
        lambda x: self.model(inputs, x), self.req_measurements, dtype=tf.float64
    )
    expval = tf.transpose(expval)
    # combine the tomography measurements
    rho = tf.einsum(&#34;no,oij-&gt;nij&#34;, expval, self.req_measurements)
    rho += tf.eye(
        2 ** self.model.req_qub_out, 2 ** self.model.req_qub_out, dtype=tf.float64
    )
    # normalization
    rho /= tf.trace(rho)[:, tf.newaxis, tf.newaxis]
    # stack probabilties for their respective classes
    return tf.stack(
        [tf.to_float(rho[:, i, i]) for i in range(rho.shape[1])], axis=1
    ).numpy()</code></pre>
</details>
</dd>
<dt id="rockyraccoon.model.core.RaccoonWrapper.train"><code class="name flex">
<span>def <span class="ident">train</span></span>(<span>self, X, y, epsilon=0.1, maxiter=100, tol=0.1)</span>
</code></dt>
<dd>
<section class="desc"><p>Train the QML model with gradient descent.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>X</code></strong></dt>
<dd>N x d matrix of N samples and d features.</dd>
<dt><strong><code>y</code></strong></dt>
<dd>Length N vector with labels.</dd>
<dt><strong><code>epsilon</code></strong></dt>
<dd>Learning rate of the optimizer.</dd>
<dt><strong><code>maxiter</code></strong></dt>
<dd>Maximum number of iterations before convergence.</dd>
<dt><strong><code>tol</code></strong></dt>
<dd>Likelihood tolerance threshhold.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def train(self, X: np.ndarray, y: np.ndarray, epsilon=0.1, maxiter=100, tol=0.1):
    &#34;&#34;&#34;
    Train the QML model with gradient descent.

    Args:
        X: N x d matrix of N samples and d features.
        y: Length N vector with labels.
        epsilon: Learning rate of the optimizer.
        maxiter: Maximum number of iterations before convergence.
        tol: Likelihood tolerance threshhold.

    &#34;&#34;&#34;
    # add bias to inputs
    if self.model.bias:
        X = self.add_bias(X)

    assert self.model.nclasses == len(
        np.unique(y)
    ), &#34;Model expects at {} classes, when y contains {} classes&#34;.format(
        self.model.nclasses, len(np.unique(y))
    )
    # determine the required measurements and get empirical statistics
    self._determine_req_measurements(False)
    self._get_discr_statistics(X, y)
    data_states = tf.map_fn(
        self.construct_density_matrix, np.sqrt(self.q_y_x), dtype=tf.float64
    )
    # multiply with qx (prior)
    data_states *= tf.reshape(self.q_x, (-1, 1, 1))
    # intialize the model
    self.model.initialize(X.shape[1])

    optimizer = tf.compat.v1.train.GradientDescentOptimizer(learning_rate=epsilon)
    self.lh = []
    # print training info
    print(&#34;-------TRAINING-------&#34;)
    print(self.model)
    print(&#34;{} samples, {} features&#34;.format(*X.shape))
    print(
        &#34;{} input qubits, {} output qubits&#34;.format(
            self.model.req_qub_in, self.model.req_qub_out
        )
    )
    # training loop
    for i in range(maxiter):
        # calculate and apply gradients
        with tf.GradientTape() as tape:
            loss_value = self.loss(X, data_states)
            grads = tape.gradient(loss_value, self.model.trainable_vars)
        optimizer.apply_gradients(
            zip(grads, self.model.trainable_vars),
            global_step=tf.compat.v1.train.get_or_create_global_step(),
        )
        self.lh.append(float(loss_value))
        if i % 20 == 0:
            print(&#34;Loss at step {:03d}: {:.6f}&#34;.format(i, loss_value))
            if abs(loss_value - self.loss(X, data_states)) &lt; tol:
                print(&#34;L&lt;{} after {:03d} iterations&#34;.format(tol, i))

                break
    print(&#34;Final loss: {:.6f}&#34;.format(self.loss(X, data_states)))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="rockyraccoon.model.core.RockyModel"><code class="flex name class">
<span>class <span class="ident">RockyModel</span></span>
<span>(</span><span>nclasses, device='default.qubit')</span>
</code></dt>
<dd>
<section class="desc"><p>QML model template.</p>
<p>Initialize the keras model interface.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>nclasses</code></strong></dt>
<dd>The number of classes in the data, used the determine the required output qubits.</dd>
<dt><strong><code>device</code></strong></dt>
<dd>name of Pennylane Device backend.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class RockyModel(tf.keras.Model):
    &#34;&#34;&#34;
    QML model template.
    &#34;&#34;&#34;

    def __init__(self, nclasses: int, device=&#34;default.qubit&#34;):
        &#34;&#34;&#34;
        Initialize the keras model interface.

        Args:
            nclasses: The number of classes in the data, used the determine the required output qubits.
            device: name of Pennylane Device backend.
        &#34;&#34;&#34;
        super(RockyModel, self).__init__()
        self.req_qub_out = int(np.ceil(np.log2(nclasses)))
        self.req_qub_in = None
        self.device = device
        self.data_dev = None
        self.model_dev = None
        self.nclasses = nclasses
        self.init = False
        self.circuit = None
        self.trainable_vars = []

    def __str__(self):
        return &#34;RockyModel Template&#34;

    def initialize(self, nfeatures: int):
        &#34;&#34;&#34;
        Model initialization.

        Args:
            nfeatures: The number of features in X

        &#34;&#34;&#34;
        self.init = True
        raise NotImplementedError

    def call(self, inputs, observable):
        &#34;&#34;&#34;
        Given some obsersable, we calculate the output of the model.

        Args:
            inputs: N x d matrix of N samples and d features.
            observable: Hermitian matrix containing an observable

        Returns: N expectation values of the observable

        &#34;&#34;&#34;

        raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tensorflow.python.keras.engine.training.Model</li>
<li>tensorflow.python.keras.engine.network.Network</li>
<li>tensorflow.python.keras.engine.base_layer.Layer</li>
<li>tensorflow.python.module.module.Module</li>
<li>tensorflow.python.training.tracking.tracking.AutoTrackable</li>
<li>tensorflow.python.training.tracking.base.Trackable</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="rockyraccoon.model.wave_fn.WaveFunction" href="wave_fn.html#rockyraccoon.model.wave_fn.WaveFunction">WaveFunction</a></li>
<li><a title="rockyraccoon.model.amplitude.AmplitudeModel" href="amplitude.html#rockyraccoon.model.amplitude.AmplitudeModel">AmplitudeModel</a></li>
<li><a title="rockyraccoon.model.nn_hybrid.HybridNN" href="nn_hybrid.html#rockyraccoon.model.nn_hybrid.HybridNN">HybridNN</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="rockyraccoon.model.core.RockyModel.call"><code class="name flex">
<span>def <span class="ident">call</span></span>(<span>self, inputs, observable)</span>
</code></dt>
<dd>
<section class="desc"><p>Given some obsersable, we calculate the output of the model.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>inputs</code></strong></dt>
<dd>N x d matrix of N samples and d features.</dd>
<dt><strong><code>observable</code></strong></dt>
<dd>Hermitian matrix containing an observable</dd>
<dt><strong><code>Returns</code></strong> :&ensp;<code>N</code> <code>expectation</code> <code>values</code> of <code>the</code> <code>observable</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def call(self, inputs, observable):
    &#34;&#34;&#34;
    Given some obsersable, we calculate the output of the model.

    Args:
        inputs: N x d matrix of N samples and d features.
        observable: Hermitian matrix containing an observable

    Returns: N expectation values of the observable

    &#34;&#34;&#34;

    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="rockyraccoon.model.core.RockyModel.initialize"><code class="name flex">
<span>def <span class="ident">initialize</span></span>(<span>self, nfeatures)</span>
</code></dt>
<dd>
<section class="desc"><p>Model initialization.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>nfeatures</code></strong></dt>
<dd>The number of features in X</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def initialize(self, nfeatures: int):
    &#34;&#34;&#34;
    Model initialization.

    Args:
        nfeatures: The number of features in X

    &#34;&#34;&#34;
    self.init = True
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="rockyraccoon.model" href="index.html">rockyraccoon.model</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="rockyraccoon.model.core.RaccoonWrapper" href="#rockyraccoon.model.core.RaccoonWrapper">RaccoonWrapper</a></code></h4>
<ul class="">
<li><code><a title="rockyraccoon.model.core.RaccoonWrapper.add_bias" href="#rockyraccoon.model.core.RaccoonWrapper.add_bias">add_bias</a></code></li>
<li><code><a title="rockyraccoon.model.core.RaccoonWrapper.construct_density_matrix" href="#rockyraccoon.model.core.RaccoonWrapper.construct_density_matrix">construct_density_matrix</a></code></li>
<li><code><a title="rockyraccoon.model.core.RaccoonWrapper.loss" href="#rockyraccoon.model.core.RaccoonWrapper.loss">loss</a></code></li>
<li><code><a title="rockyraccoon.model.core.RaccoonWrapper.measurements" href="#rockyraccoon.model.core.RaccoonWrapper.measurements">measurements</a></code></li>
<li><code><a title="rockyraccoon.model.core.RaccoonWrapper.predict" href="#rockyraccoon.model.core.RaccoonWrapper.predict">predict</a></code></li>
<li><code><a title="rockyraccoon.model.core.RaccoonWrapper.train" href="#rockyraccoon.model.core.RaccoonWrapper.train">train</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="rockyraccoon.model.core.RockyModel" href="#rockyraccoon.model.core.RockyModel">RockyModel</a></code></h4>
<ul class="">
<li><code><a title="rockyraccoon.model.core.RockyModel.call" href="#rockyraccoon.model.core.RockyModel.call">call</a></code></li>
<li><code><a title="rockyraccoon.model.core.RockyModel.initialize" href="#rockyraccoon.model.core.RockyModel.initialize">initialize</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>